{
//  classHeader="header.txt"
  parserClass="ro.redeul.google.go.parser.GoParser"
  parserUtilClass="ro.redeul.google.go.parser.GoParserUtil"
//  parserUtilClass="ro.redeul.google.go.parser.GoParserUtil"

  implements="ro.redeul.google.go.lang.psi.GoPsiElement"
  extends="ro.redeul.google.go.lang.psi.impl.GoPsiElementBase"

  psiClassPrefix="Go"
  psiImplClassSuffix="Impl"
  psiPackage="ro.redeul.google.go.psi"
  psiImplPackage="ro.redeul.google.go.psi.impl"
  psiImplUtilClass="ro.redeul.google.go.psi.impl.GoPsiImplUtil"

  elementTypeHolderClass="ro.redeul.google.go.psi.impl.GoTypes"
  elementTypePrefix="GO_"
  elementTypeClass="ro.redeul.google.go.psi.GoCompositeElementType"
  tokenTypeClass="ro.redeul.google.go.psi.GoTokenType"
  generateTokens="true"

  tokens = [
    K_IMPORT="import"
    K_PACKAGE="package"
    K_CONST="const"
    K_STRUCT="struct"
    K_FUNC="func"
    K_TYPE="type"
    K_INTERFACE="interface"
    K_RETURN="return"
    K_BREAK="break"
    K_CONTINUE="continue"
    K_GOTO="goto"
    K_FALLTHROUGH="fallthrough"
    K_IF="if"
    K_ELSE="else"
    K_SWITCH="switch"
    K_CASE="case"
    K_DEFAULT="default"
    K_SELECT="select"
    K_FOR="for"
    K_DEFER="defer"
    K_GO="go"
    K_MAP="map"
    K_CHAN="chan"
    K_VAR="var"
    K_RANGE="range"

    OP_DOTS="..."

    PLUS_PLUS="++"
    MINUS_MINUS="--"

    OP_AND="&&"
    OP_OR="||"

    OP_ADD="+"
    OP_SUB="-"
    OP_BIT_OR="|"
    OP_BIT_XOR="^"

    OP_LEFT_SHIFT="<<"
    OP_RIGHT_SHIFT=">>"

    OP_NOT="!"
    OP_CHAN='<-'

    OP_EQ_EQ="=="
    OP_NOT_EQ="!="
    OP_LESS_EQ="<="
    OP_GREAT_EQ=">="
    OP_LESS="<"
    OP_GREAT=">"

    OP_STAR="*"
    OP_DIV="/"
    OP_MOD="%"


    OP_BIT_CLEAR="&^"
    OP_BIT_AND="&"

    OP_EQ="="
    OP_DOT="."
    OP_COMMA=','

    OP_ASSIGN=":="
    OP_COLON=":"

    SEMI=";"

    comment="regexp://.*"
    identifier="regexp:(\p{L}|_)(\p{L}|\p{Nd}|_)*"
    raw_string_lit="regexp:`[^`]*`"

    decimal_lit="regexp:[1-9][0-9]*"
    octal_lit="regexp:0[0-7]*"
    hex_lit="regexp:0[xX][0-9A-Fa-f]+"

    L_PAREN="("
    R_PAREN=")"
    L_BRACE="{"
    R_BRACE="}"
    L_BRACKET="["
    R_BRACKET="]"
  ]

//  implements("rule|attr")="org.intellij.grammar.psi.BnfNamedElement"
//  extends("rule|attr")="org.intellij.grammar.psi.impl.BnfNamedElementImpl"
//  mixin("reference_or_token")="org.intellij.grammar.psi.impl.BnfRefOrTokenImpl"
//  mixin("string_literal_expression")="org.intellij.grammar.psi.impl.BnfStringImpl"
//  extends("paren_.*expression")=parenthesized

//  methodRenames("getStringLiteralExpression")="getLiteralExpression"
}

file ::= PackageClause ';' (ImportDecl ';')* (TopLevelDecl ';')*
PackageClause       ::= "package" PackageName {pin=1}
private PackageName ::= identifier

ImportDecl       ::= 'import' (ImportSpec | '(' (ImportSpec ';' )+ ')' ) { pin=1 }
ImportSpec       ::= [ '.' | PackageName ] ImportPath
private ImportPath       ::= string_lit

TopLevelDecl ::= Declaration | FunctionDecl | MethodDecl
Declaration ::= ConstDecl | TypeDecl | VarDecl

ConstDecl ::= 'const' (ConstSpec | '(' ( ConstSpec ";" )+ ')' ) { pin=1 extends=Declaration}
ConstSpec ::= IdentifierList "=" Expression

TypeDecl     ::= "type" ( TypeSpec | "(" ( TypeSpec ";" )* ")" ) { pin=1 extends=Declaration}
TypeSpec     ::= identifier Type

VarDecl     ::= "var" ( VarSpec | "(" ( VarSpec ";" )* ")" ) { pin=1 extends=Declaration}
VarSpec     ::= IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList )

IdentifierList ::= identifier ( "," identifier )*
ExpressionList ::= Expression ( "," Expression )*

string_lit  ::= raw_string_lit //| int_string_lit

Type      ::= TypeName | TypeLit | "(" Type ")"
TypeName  ::= identifier | QualifiedIdent { extends=Type }
TypeLit   ::= ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType { extends=Type }

QualifiedIdent ::= PackageName '.' identifier

ArrayType ::= "[" ArrayLength "]" ElementType { extends=TypeLit }
ArrayLength ::= Expression
private ElementType ::= Type

StructType          ::= "struct" '{' ( FieldDecl ';' )* '}' { pin=1 extends=TypeLit }
FieldDecl           ::= (IdentifierList Type | AnonymousField) Tag?
AnonymousField      ::= '*'? TypeName
Tag                 ::= string_lit

PointerType       ::= "*" BaseType { pin=1 extends=TypeLit }
private BaseType  ::= Type

FunctionType   ::= "func" Signature { pin=1 extends=TypeLit }
Signature      ::= Parameters [ Result ]
Result         ::= Parameters | Type
Parameters     ::= '(' ( ParameterList ','? )? ')'
ParameterList  ::= ParameterDecl ( ',' ParameterDecl )*
ParameterDecl  ::= IdentifierList? "..."? Type

InterfaceType      ::= "interface" '{' (MethodSpec ";")* '}' { pin=1 extends=TypeLit }
MethodSpec         ::= MethodName Signature | InterfaceTypeName
MethodName         ::= identifier
InterfaceTypeName  ::= TypeName

SliceType          ::= '[' ']' ElementType { pin=2 extends=TypeLit }

MapType     ::= 'map' '[' KeyType ']' ElementType { pin=1 extends=TypeLit }
KeyType     ::= Type

ChannelType ::= ("chan" "<-"? | "<-" "chan" ) ElementType { pin=1 extends=TypeLit }


FunctionDecl ::= "func" FunctionName ( Function | Signature ) { pin=2 }
FunctionName ::= identifier
Function     ::= Signature FunctionBody
FunctionBody ::= Block

MethodDecl   ::= "func" Receiver MethodName ( Function | Signature ) { pin=2 }
Receiver     ::= "(" identifier? "*"? BaseTypeName ")"
BaseTypeName ::= identifier

//Block ::= "{"  "}"
Block           ::= "{" StatementList "}"
StatementList   ::= ( Statement ";" )*

Statement ::= Declaration |
    LabeledStmt |
    SimpleStmt |
	GoStmt |
	ReturnStmt |
	BreakStmt |
	ContinueStmt |
	GotoStmt |
	FallthroughStmt |
	Block |
	IfStmt |
	SwitchStmt |
	SelectStmt |
	ForStmt |
	DeferStmt

SimpleStmt ::=
    //EmptyStmt |
    ExpressionStmt |
    SendStmt |
    IncDecStmt |
    Assignment |
    ShortVarDecl

LabeledStmt ::= Label ":" Statement
Label       ::= identifier

GoStmt          ::= "go" Expression { pin=1 }
ReturnStmt      ::= "return" ExpressionList? { pin=1 }
BreakStmt       ::= "break" Label? { pin=1 }
ContinueStmt    ::= "continue" Label? { pin=1 }
GotoStmt        ::= "goto" Label { pin=1 }
FallthroughStmt ::= "fallthrough" { pin=1 }
IfStmt          ::= "if" ( SimpleStmt ";" )? Expression Block ( "else" ( IfStmt | Block ) )? { pin=1 }

SwitchStmt      ::= ExprSwitchStmt | TypeSwitchStmt
ExprSwitchStmt  ::= "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" { pin=1 }
ExprCaseClause  ::= ExprSwitchCase ":" StatementList
ExprSwitchCase  ::= "case" ExpressionList | "default"

TypeSwitchStmt  ::= "switch" ( SimpleStmt ";" )? TypeSwitchGuard "{" TypeCaseClause* "}" { pin=1 }
TypeSwitchGuard ::= (identifier ":=")? PrimaryExpr "." "(" "type" ")"
TypeCaseClause  ::= TypeSwitchCase ":" StatementList { pin=1 }
TypeSwitchCase  ::= "case" TypeList | "default"
TypeList        ::= Type ( "," Type )*

SelectStmt      ::= "select" "{" CommClause* "}" { pin=1 }
CommClause      ::= CommCase ":" StatementList { pin=1 }
CommCase        ::= "case" ( SendStmt | RecvStmt ) | "default"
RecvStmt        ::= ( ExpressionList "=" | IdentifierList ":=" )? RecvExpr
RecvExpr        ::= Expression

ForStmt         ::= "for" ( Condition | ForClause | RangeClause )? Block { pin=1 }
Condition       ::= Expression

ForClause       ::= InitStmt? ";" Condition? ";" PostStmt?
InitStmt        ::= SimpleStmt
PostStmt        ::= SimpleStmt

RangeClause     ::= ( ExpressionList "=" | IdentifierList ":=" ) "range" Expression

DeferStmt       ::= "defer" Expression { pin=1 }

ExpressionStmt  ::= Expression

SendStmt        ::= Channel "<-" Expression
Channel         ::= Expression

IncDecStmt      ::= Expression ( "++" | "--" )

Assignment      ::= ExpressionList assign_op ExpressionList
assign_op       ::= ( '+' | '-' | '|' | '^' | "/" | "%" | "<<" | ">>" | "&" | "&^" | '*' )? "="

ShortVarDecl    ::= IdentifierList ":=" ExpressionList

Expression      ::= BinaryExpr | UnaryExpr
//    Expression binary_op UnaryExpr

UnaryExpr       ::=
    PrimaryExpr | ("+" | "-" | "!" | "^" | "*" | "&" | "<-")? UnaryExpr {extends=Expression}

private BinaryExpr  ::= MultiplicativeExpr | AdditiveExpr | ComparisonExpr | LogicalAndExpr | LogicalOrExpr { extends=Expression }

MultiplicativeExpr  ::= Expression ("*" | "/" | "%" | "<<" | ">>" | "&" | "&^") Expression { extends=Expression }
AdditiveExpr        ::= Expression ("+" | "-" | "|" | "^") Expression { extends=Expression }
ComparisonExpr      ::= Expression ("==" | "!=" | "<" | "<=" | ">" | ">=") Expression { extends=Expression }
LogicalAndExpr      ::= Expression "&&" Expression { extends=Expression }
LogicalOrExpr       ::= Expression "||" Expression { extends=Expression }

PrimaryExpr ::= ExtendedPrimaryExpr | BasePrimaryExpr { extends=Expression }

private BasePrimaryExpr ::= Operand | Conversion | BuiltinCall
private ExtendedPrimaryExpr ::= BasePrimaryExpr extra_rule

private extra_rule ::=
    (SliceExpr | IndexExpr | SelectorExpr | TypeAssertionExpr | CallExpr) extra_rule?

left SelectorExpr       ::= "." identifier { extends=PrimaryExpr }
left IndexExpr          ::= "[" Expression "]" { extends=PrimaryExpr }
left SliceExpr          ::= "[" Expression? ":" Expression? "]" { extends=PrimaryExpr }
left TypeAssertionExpr  ::= "." "(" Type ")" { extends=PrimaryExpr }
left CallExpr           ::= "(" (ArgumentList ","? )? ")" {extends=PrimaryExpr}

ArgumentList   ::= ExpressionList "..."?

private Operand  ::= Literal | OperandName | MethodExpr | "(" Expression ")" { extends=PrimaryExpr }
Literal    ::= BasicLit | CompositeLit | FunctionLit { extends=PrimaryExpr }
BasicLit   ::= int_lit | /* float_lit | imaginary_lit | rune_lit | */ string_lit
OperandName ::= QualifiedIdent | identifier

int_lit     ::= decimal_lit | octal_lit | hex_lit { extends=BasicLit }

Conversion ::= Type "(" Expression ","? ")"

BuiltinCall ::= identifier "(" [ BuiltinArgs [ "," ] ] ")"
BuiltinArgs ::= Type ( "," ArgumentList )? | ArgumentList

MethodExpr    ::= ReceiverType "." MethodName
ReceiverType  ::= TypeName | "(" "*" TypeName ")" | "(" ReceiverType ")"


CompositeLit  ::= LiteralType LiteralValue
LiteralType   ::= StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName
LiteralValue  ::= "{" ( ElementList ","? )? "}"
ElementList   ::= Element ( "," Element )*
Element       ::= ( Key ":")? Value
Key           ::= FieldName | ElementIndex
FieldName     ::= identifier
ElementIndex  ::= Expression
Value         ::= Expression | LiteralValue

FunctionLit   ::= "func" Function


//external grammar ::= parseGrammar grammar_element
//private grammar_element ::= !<<eof>> (attrs | rule) {pin=1 recoverUntil=grammar_element_recover}
//private grammar_element_recover::=!('{'|rule_start)
//
//rule ::= rule_start expression attrs? ';'? {pin=2}
//private rule_start ::= modifier* id '::='
//modifier ::= 'private' | 'external' | 'meta' | 'inner' | 'left' | 'fake'
//
//
//attrs ::= '{' attr * '}' {pin=1}
//attr ::= attr_start attr_value ';'? {pin=1 recoverUntil=attr_recover_until}
//private attr_start ::= id (attr_pattern '=' | '=') {pin(".*")="attr_pattern"}
//private attr_start_simple ::= id attr_pattern? '='
//private attr_recover_until ::= !('}' | attr_start)
//private attr_value ::= (reference_or_token | literal_expression | value_list) !'='
//attr_pattern ::= '(' string_literal_expression ')' {pin=1}
//
//value_list ::= '[' list_entry * ']' {pin=1 extends=expression}
//list_entry ::= (id list_entry_tail? | string_literal_expression) ';'? {
//  recoverUntil=list_entry_recover_until
//  methods=[getReferences]
//}
//private list_entry_tail ::= '=' string_literal_expression {pin=1}
//private list_entry_recover_until ::= !(']' | '}' | id | string)
//
//expression ::= sequence choice?
//sequence ::= option * {extends=expression recoverUntil=sequence_recover}
//private sequence_recover ::= !(';'|'|'|'('|')'|'['|']'|'{'|'}') grammar_element_recover
//private option ::= predicate | paren_opt_expression | simple quantified?
//
//left choice ::= ( '|' sequence ) + {pin(".*")=1 extends=expression}
//left quantified ::= quantifier {extends=expression }
//quantifier ::= '?' | '+' | '*'
//
//predicate ::= predicate_sign simple {extends=expression}
//predicate_sign ::= '&' | '!'
//
//fake parenthesized ::= '(' expression ')' {extends=expression}
//private simple ::= !(modifier* id '::=' ) reference_or_token | literal_expression | external_expression | paren_expression
//external_expression ::= '<<' reference_or_token option * '>>' {pin=2 extends=expression}
//reference_or_token ::= id  {extends=expression }
//literal_expression ::= string_literal_expression | number {extends=expression }
//string_literal_expression ::= string {extends=literal_expression}
//paren_expression ::= '(' expression ')' | '{' alt_choice_element '}' {pin(".*")=2}
//paren_opt_expression ::= '[' expression ']' {pin=2}
//private alt_choice_element ::= !attr_start_simple expression